/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package us.frankkelly.soccer;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * TODO
 * Players per Rotation = Half the bench
 * Different Assignment strategies
 *  - Time per player
 *  - Strongest First Half
 *  - Add random factor
 *  - Alternate Front/Back in 2nd Half
 */
public class App {
    
    private static final int GOALIE = 1;
    private static final int ELEVEN_VS_ELEVEN = 11;
    private List<Player> team;
    private Player firstHalfGoalie, secondHalfGoalie;
    private int lengthOfGameInMinutes=70, rotationsPerHalf=5, playersPerRotation=3;
    private Map<String,Integer> timePerPlayer = new TreeMap<>();

    public static void main(String[] args) {
        new App();
    }
    
    public App() {
        try {
            team = loadTeamFromClasspath( "gr78-red.csv");
            loadPreferences();
            calculateRotationForGame(team, firstHalfGoalie, secondHalfGoalie);
        } catch (Exception e) {
            System.err.println("Exception " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    private Rotation getRotation() {
        return new Rotation433();
    }
    
    private void loadPreferences() {        
        System.out.println("Enter Player # for Goalie for 1st Half: ");
        Scanner scanner = new Scanner(System.in);
        int i = scanner.nextInt();
        if(i < 1 || i > team.size()) {
            System.err.println("There is no player with that #. Exiting . . .");
            System.exit(-1);
        }
        firstHalfGoalie = team.get(i-1);
        System.out.println("Goalie for 1st Half: " + firstHalfGoalie.getName());
        
        System.out.println("Enter Player # for Goalie for 2nd Half: ");
        scanner = new Scanner(System.in);
        i = scanner.nextInt();
        if(i < 1 || i > team.size()) {
            System.err.println("There is no player with that #. Exiting . . .");
            System.exit(-1);
        }
        secondHalfGoalie = team.get(i-1);
        System.out.println("Goalie for 2nd Half: " + secondHalfGoalie.getName());
        scanner.close();
    }
    
    public void calculateRotationForGame(List<Player> team, Player goalie1, Player goalie2) {
        List<Player> fullTeamCopy = new ArrayList<>(team);
        List<Player> teamOnTheSideline = new ArrayList<>(team);
        
        //First Half
        System.out.println("===============");
        System.out.println("= ROTATIONS   =");
        System.out.println("===============");
        

        System.out.println("************");
        System.out.println("* 1ST HALF *");
        System.out.println("************");
        firstHalfRotation(team, goalie1, lengthOfGameInMinutes, rotationsPerHalf);
        
        System.out.println("************");
        System.out.println("* 2ND HALF *");
        System.out.println("************");
        secondHalfRotation(team, goalie2, lengthOfGameInMinutes, rotationsPerHalf);
        
        printPlayingTime();
    }
    
    private void firstHalfRotation(List<Player> team, Player goalie, int lengthOfGameInMinutes, int rotationsPerHalf) {

        int gameTime = 0;
        int timePerRotation =  lengthOfGameInMinutes/(rotationsPerHalf*2);
        List<Player> fullTeamCopy = new ArrayList<>(team);
        List<Player> teamOnTheSideline = new ArrayList<>(team);
        Rotation firstHalfPlayersOnTheField = getRotation();
        firstHalfPlayersOnTheField.setGoalie(goalie);
        fullTeamCopy.remove(goalie);
        teamOnTheSideline.remove(goalie);
        
        //Create initial Rotation
        for(int i=0; i< ELEVEN_VS_ELEVEN - GOALIE; i++) {
            Player p = fullTeamCopy.get(i);
            firstHalfPlayersOnTheField.addPlayer(p); 
            teamOnTheSideline.remove(p);
        }
        firstHalfPlayersOnTheField.print(1, gameTime, gameTime += timePerRotation);
        printSidelineList(teamOnTheSideline);
        printSeparator();        
        
        //Create following rotations
        for(int i=2; i<= rotationsPerHalf; i++) {
            updateTotalPlayingTime(firstHalfPlayersOnTheField, timePerRotation);
            for(int j=0; j< playersPerRotation; j++) {
                Player replaced = firstHalfPlayersOnTheField.replacePlayer(teamOnTheSideline.remove(0));
                teamOnTheSideline.add(replaced);
            }
            
            firstHalfPlayersOnTheField.print(i, gameTime, gameTime += timePerRotation);
            printSidelineList(teamOnTheSideline);
            printSeparator();
        }
        //Record last rotation playing time
        updateTotalPlayingTime(firstHalfPlayersOnTheField, (lengthOfGameInMinutes/2)-gameTime);
        printPlayingTime();
    }
    
    private void secondHalfRotation(List<Player> team, Player goalie, int lengthOfGameInMinutes, int rotationsPerHalf) {
      //Second Half

        int timePerRotation =  lengthOfGameInMinutes/(rotationsPerHalf*2);
        int gameTime = lengthOfGameInMinutes/2;
        List<Player> fullTeamCopy = new ArrayList<>(team);
        List<Player> teamOnTheSideline = new ArrayList<>(team);

        Rotation secondHalfPlayersOnTheField = getRotation();
        teamOnTheSideline = new ArrayList<>(team);
        secondHalfPlayersOnTheField.setGoalie(goalie);
        fullTeamCopy.remove(goalie);
        teamOnTheSideline.remove(goalie);
        for(int i=0; i< ELEVEN_VS_ELEVEN - GOALIE; i++) {
            //IMPORTANT: This time starting from the back
            Player p = fullTeamCopy.get((fullTeamCopy.size()-1)-i);
            secondHalfPlayersOnTheField.addPlayer(p); 
            teamOnTheSideline.remove(p);
        }
        secondHalfPlayersOnTheField.print(1, gameTime, gameTime += timePerRotation);
        printSidelineList(teamOnTheSideline);
       
        //Create following Rotations
        for(int i=2; i<= rotationsPerHalf; i++) {
            updateTotalPlayingTime(secondHalfPlayersOnTheField, timePerRotation);
            for(int j=0; j< playersPerRotation; j++) {
                Player replaced = secondHalfPlayersOnTheField.replacePlayer(teamOnTheSideline.remove(0));
                teamOnTheSideline.add(replaced);
            }
            secondHalfPlayersOnTheField.print(i, gameTime, gameTime += timePerRotation);
            printSidelineList(teamOnTheSideline);
        }
        //Record last rotation playing time
        updateTotalPlayingTime(secondHalfPlayersOnTheField, lengthOfGameInMinutes-gameTime);
    }
    private void printPlayingTime() {      
        printSeparator();
        System.out.println("* PLAYING TIME TOTALS *");
        for(Map.Entry<String, Integer> entry : timePerPlayer.entrySet()) {
            System.out.println(entry.getKey() + " --> " + entry.getValue() + " mins");
        }
        printSeparator();
    }

    private void printSeparator() {
        System.out.println("-----------------------------------------");    
    }
    
    private void updateTotalPlayingTime(Rotation r, int playingTime) {
        for (String s : r.getPlayerNames()) {
            if (!timePerPlayer.containsKey(s)) {
                timePerPlayer.put(s, playingTime);
            } else {
                int earlierTime = timePerPlayer.get(s);
                timePerPlayer.put(s, earlierTime + playingTime);
            }
        }
        // Useful for debugging playingTime
        // printPlayingTime();
    }

    private void printSidelineList(List<Player> list) {
        System.out.println("Available / Resting");
        for(Player p : list) {
            System.out.println(" " + p.getName() + " " + p.getScore());
        }
        printSeparator();
    }
    
    private List<Player> loadTeamFromClasspath(String fileName) throws Exception {
        Path path = Paths.get(getClass().getClassLoader().getResource(fileName).toURI());
        Stream<String> stream = Files.lines(path);

        List<Player> list = stream.map(Player::getPlayer).collect(Collectors.toList());
        stream.close();
        Collections.sort(list);

        int i = 1;
        for (Player p : list) {
            System.out.println("Player #" + i++ + ") " + p.getName() + " " + p.getScore());
        }
        return Collections.unmodifiableList(list);
    }
}
